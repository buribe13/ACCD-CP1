<!-- vibed out in cursor -->
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>the cat, westwood, 2024</title>
    <style>
      html,
      body {
        height: 100%;
        margin: 0;
        background: #000;
        color: #fff;
        overflow: hidden;
      }
      #asciiContainer {
        height: 100vh;
        width: 100vw;
        display: flex;
        align-items: center;
        justify-content: center;
      }
      pre#ascii {
        margin: 0;
        font-family: "Courier New", Courier, monospace;
        white-space: pre;
        line-height: 0.9;
        letter-spacing: 0px;
        user-select: none;
        font-weight: 700;
        transform-origin: center center;
      }
      canvas#workerCanvas {
        position: fixed;
        left: -9999px;
        top: -9999px;
        width: 0;
        height: 0;
        pointer-events: none;
        visibility: hidden;
      }
    </style>
    <link rel="preload" as="image" href="./kat1.jpg" />
    <link rel="preload" as="font" href="" crossorigin />
    <meta name="color-scheme" content="dark light" />
    <meta
      name="description"
      content="ASCII art rendering of kat1.jpg filling the viewport height."
    />
    <meta name="robots" content="noindex" />
    <meta name="theme-color" content="#000000" />
    <script>
      window.addEventListener("DOMContentLoaded", () => {
        const asciiPre = document.getElementById("ascii");
        const container = document.getElementById("asciiContainer");
        const workerCanvas = document.getElementById("workerCanvas");
        const ctx = workerCanvas.getContext("2d", { willReadFrequently: true });

        // From lightest to darkest so we can index by inverted luminance
        const density =
          " .'`^\",:;Il!i~+_-?][}{1)(|\\/*tfjrxnuvczXYUJCLQ0OZmwqpdbkhao*#MW&8%B@$";

        const img = new Image();
        img.src = "./kat1.jpg";
        img.decoding = "async";
        img.addEventListener("load", () => {
          renderAscii();
        });
        img.addEventListener("error", () => {
          asciiPre.textContent = "Image not found: kat1.jpg";
        });

        let resizeTimer = null;
        window.addEventListener(
          "resize",
          () => {
            clearTimeout(resizeTimer);
            resizeTimer = setTimeout(renderAscii, 100);
          },
          { passive: true }
        );

        function computeFontWidthToHeightRatio() {
          // Approximate width/height ratio for Courier on most platforms
          return 0.6; // character width ≈ 0.6 × font-size
        }

        function buildAsciiFromCanvas(pixelWidth, pixelHeight) {
          const imageData = ctx.getImageData(
            0,
            0,
            pixelWidth,
            pixelHeight
          ).data;
          const chars = [];
          const gamma = 0.9; // < 1 brightens midtones
          const contrast = 1.25; // > 1 increases contrast
          const brightness = 0.02; // small lift
          for (let y = 0; y < pixelHeight; y++) {
            let row = "";
            for (let x = 0; x < pixelWidth; x++) {
              const idx = (y * pixelWidth + x) * 4;
              const r = imageData[idx];
              const g = imageData[idx + 1];
              const b = imageData[idx + 2];
              // Perceived luminance (sRGB)
              const luminance = 0.2126 * r + 0.7152 * g + 0.0722 * b;
              // Map luminance -> density with gamma/contrast/brightness for visibility
              let t = 1 - luminance / 255; // dark -> 1
              t = Math.pow(Math.max(0, Math.min(1, t)), gamma);
              t = (t - 0.5) * contrast + 0.5 + brightness;
              t = Math.max(0, Math.min(1, t));
              const charIndex = Math.min(
                density.length - 1,
                Math.max(0, Math.floor(t * density.length))
              );
              row += density.charAt(charIndex);
            }
            chars.push(row);
          }
          return chars.join("\n");
        }

        function renderAscii() {
          if (!img.complete || !img.naturalWidth) return;

          const containerWidth = container.clientWidth;
          const containerHeight = container.clientHeight; // 100vh

          const fontWH = computeFontWidthToHeightRatio();
          const lineHeightFactor = 0.9; // keep in sync with CSS

          // Choose detail based on height, then compute width values.
          let rows = Math.max(
            80,
            Math.min(320, Math.floor(containerHeight / 6))
          );
          let fontSizePx = containerHeight / rows; // ensures text height equals container height before transform
          let cols = Math.max(
            40,
            Math.floor(containerWidth / (fontSizePx * fontWH))
          );

          // Prepare worker canvas at character-resolution
          workerCanvas.width = cols;
          workerCanvas.height = rows;

          // Draw image stretched to exactly fill the character grid (intentionally ignoring aspect ratio)
          ctx.clearRect(0, 0, cols, rows);
          ctx.imageSmoothingEnabled = true;
          ctx.imageSmoothingQuality = "high";
          ctx.drawImage(img, 0, 0, cols, rows);

          // Build ASCII
          const ascii = buildAsciiFromCanvas(cols, rows);
          asciiPre.style.fontSize = fontSizePx.toFixed(3) + "px";
          asciiPre.textContent = ascii;

          // Precisely stretch the text block to fill both width and height
          const naturalTextWidth = cols * fontSizePx * fontWH;
          const naturalTextHeight = rows * fontSizePx * lineHeightFactor;
          const scaleX = containerWidth / naturalTextWidth;
          const scaleY = containerHeight / naturalTextHeight;
          asciiPre.style.transform = `scale(${scaleX.toFixed(
            5
          )}, ${scaleY.toFixed(5)})`;
        }
      });
    </script>
  </head>
  <body>
    <div id="asciiContainer">
      <pre id="ascii">Loading…</pre>
    </div>
    <canvas id="workerCanvas"></canvas>
  </body>
</html>
